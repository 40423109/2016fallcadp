<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>2016Fall 電腦輔助設計實習 (虎尾科大MDE)</title><link href="./" rel="alternate"></link><link href="./feeds/all.atom.xml" rel="self"></link><id>./</id><updated>2017-01-15T12:16:00+08:00</updated><entry><title>2016Fall 電腦輔助設計實習課程總結 (一)</title><link href="./2016fall-dian-nao-fu-zhu-she-ji-shi-xi-ke-cheng-zong-jie-yi.html" rel="alternate"></link><published>2017-01-15T12:16:00+08:00</published><updated>2017-01-15T12:16:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-01-15:./2016fall-dian-nao-fu-zhu-she-ji-shi-xi-ke-cheng-zong-jie-yi.html</id><summary type="html">&lt;p&gt;歷年電腦輔助設計實習課程內容比較, 2016FallCADP 未涵蓋之內容, 將部份納入 2017SpringCD 課程中.&lt;/p&gt;


&lt;p&gt;在 2015Fall CADP 課程中 (2015.10.26), 我們寫下&lt;a href="http://wordpress-2015course.rhcloud.com/?m=20151026"&gt;大學生應有的學習態度&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;面對全球協同的知識經濟環境, 身為一個大學生, 至少必須:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不要怕困難 (基本信念) – 因為幾乎處於網路時代的所有人, 在享受高度科技發展所帶來的便利性之後, 都必須隨時獨力或合力克服各種困難.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要失去熱忱 (強化動力) – 許多人在生活周遭都會碰到非常多不盡如人意的各種挑戰, 持續保持個人與團隊的處事熱忱, 是堅持克服困難的必備動力.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要以為不可能 (終究達陣) – 只要個人不斷提升待人處事能力, 持續接觸人文養分, 並且在團隊機制的架構下, 以轉知為智的精神來解決各式問題, 假以時日, 便可實現團隊理想, 化不可能為可能!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;並且提供&lt;a href="./../data/TPEA_2013112021132.pdf"&gt;培養新世紀大學生的關鍵能力&lt;/a&gt; (2013.11)作為參考.&lt;/p&gt;
&lt;p&gt;文章中指出學習的五大支柱為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;學會求知（learning to know）&lt;/li&gt;
&lt;li&gt;學會做事（learning to do）&lt;/li&gt;
&lt;li&gt;學會共同生活（learning to live together）&lt;/li&gt;
&lt;li&gt;學會發展（learning to be）&lt;/li&gt;
&lt;li&gt;學會改變（learning to change)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至於在 2014Fall CADP 課程中, 我們&lt;a href="http://cadp.kmol.info/get_page?heading=%E6%82%A8%E7%9F%A5%E9%81%93%E5%97%8E?"&gt;引用&lt;/a&gt;以美國為觀點的 Did you know? 系列影片, 2016 年的版本為:&lt;/p&gt;
&lt;iframe width="640" height="480" src="https://www.youtube.com/embed/uqZiIO0YI7Y" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;2014Fall CADP 所提供的&lt;a href="./../data/cadp_project_ex1.pdf"&gt;專案範例&lt;/a&gt;, 以及 &lt;a href="./../data/pyIGES"&gt;PyIGES&lt;/a&gt; 專案.&lt;/p&gt;
&lt;p&gt;2014Fall CADP 課程內容備份為: &lt;a href="http://2014cadp.kmol.info"&gt;2014cadp.kmol.info&lt;/a&gt; 採用 &lt;a href="https://github.com/chiamingyen/pygroup"&gt;Pygroup&lt;/a&gt; 系統. 這是一套使用 &lt;a href="http://cherrypy.org/"&gt;CherryPy&lt;/a&gt; 與 &lt;a href="https://sqlite.org/"&gt;SQLite&lt;/a&gt; 及 &lt;a href="https://www.mysql.com/"&gt;MySQL&lt;/a&gt; 的網際群組軟體. 在 2015Fall 之後, 已經利用 &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; 取代 &lt;a href="http://cherrypy.org/"&gt;CherryPy&lt;/a&gt;, 成為 &lt;a href="https://github.com/chiamingyen/pygrouf"&gt;Pygrouf&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;2014Fall CADP 專案0:&lt;/p&gt;
&lt;p&gt;2014Fall CADP 練習項目 1:&lt;/p&gt;

&lt;p&gt;利用可攜程式環境, 在近端啟動"猜數字遊戲第一版, 程式碼位於 &lt;a href="https://github.com/chiamingyen/cp_project/releases"&gt;https://github.com/chiamingyen/cp_project/releases&lt;/a&gt; 標籤 cp_v1&lt;/p&gt;

&lt;p&gt;2014Fall CADP 練習項目 2:&lt;/p&gt;

&lt;p&gt;請將 cp_v1 部署到近端與遠端網際系統&lt;/p&gt;

&lt;p&gt;2014Fall CADP 練習項目 3:&lt;/p&gt;

&lt;p&gt;利用 Solvespace 建立一個簡單的四連桿機構, 當主動桿旋轉 360 度後, 請輸出中間桿上三角形頂點的移動路徑座標&lt;/p&gt;

&lt;p&gt;請自行利用程式進行相同尺寸四連桿的運動模擬, 並計算出中間桿上三角形頂點的移動路徑座標, 並與 Solvespace 的輸出結果比較&lt;/p&gt;

&lt;p&gt;平面四連桿位置分析: &lt;a href="http://www.softintegration.com/chhtml/toolkit/mechanism/fourbar/fourbarpos.html"&gt;http://www.softintegration.com/chhtml/toolkit/mechanism/fourbar/fourbarpos.html&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;請利用 &lt;a href="./../data/law_of_cosine.pdf"&gt;law of cosine&lt;/a&gt;, 將 cp_vp 以 Brython 執行四連桿運動模擬:
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;!-- &lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt; --&gt;

&lt;script type="text/javascript" src="https://cdn.rawgit.com/brython-dev/brython/3.2.9/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="600" height="450"&gt;&lt;/canvas&gt;
&lt;script type="text/python3"&gt;
from browser import document
import math
import time
from browser import timer

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )

# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 繪製方法
    def drawMe(self, g, r):
        self.g = g
        self.r = r
        self.g.save()
        self.g.moveTo(self.x,self.y)
        self.g.beginPath()
        # 根據 r 半徑繪製一個圓代表點的所在位置
        self.g.arc(self.x, self.y, self.r, 0, 2*math.pi, True)
        self.g.moveTo(self.x,self.y)
        self.g.lineTo(self.x+self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x-self.r, self.y)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y+self.r)
        self.g.moveTo(self.x, self.y)
        self.g.lineTo(self.x, self.y-self.r)
        self.g.restore()
        self.g.stroke()

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)

    # 利用文字標示點的座標位置
    def tag(self, g):
        self.g = g
        self.g.beginPath()
        self.g.fillText("%d, %d"%(self.x, self.y),self.x, self.y)
        self.g.stroke()


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail

    def drawMe(self, g):
        self.g = g
        self.g.beginPath()
        self.g.moveTo(self.p1.x,self.p1.y)
        self.g.lineTo(self.p2.x,self.p2.y)
        self.g.stroke()

    def test(self):
        return ("this is pure test to Inherit")


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))

    #g context
    def drawMe(self, g):
        self.g = g
        hole = 5
        radius = 10
        length = self.getR()
        # alert(length)
        # 儲存先前的繪圖狀態
        self.g.save()
        self.g.translate(self.p1.x,self.p1.y)
        #alert(str(self.p1.x)+","+str(self.p1.y))
        #self.g.rotate(-((math.pi/2)-self.getT()))
        self.g.rotate(-math.pi*0.5 + self.getT())
        #alert(str(self.getT()))
        #self.g.rotate(10*math.pi/180)
        #this.g.rotate(-(Math.PI/2-this.getT()));
        # 必須配合畫在 y 軸上的 Link, 進行座標轉換, 也可以改為畫在 x 軸上...
        self.g.beginPath()
        self.g.moveTo(0,0)
        self.g.arc(0, 0, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,length)
        self.g.beginPath()
        self.g.arc(0,length, hole, 0, 2*math.pi, True)
        self.g.stroke()
        self.g.moveTo(0,0)
        self.g.beginPath()
        self.g.arc(0,0, radius, 0, math.pi, True)
        self.g.moveTo(0+radius,0)
        self.g.lineTo(0+radius,0+length)
        self.g.stroke()
        self.g.moveTo(0,0+length)
        self.g.beginPath()
        self.g.arc(0, 0+length, radius, math.pi, 0, True)
        self.g.moveTo(0-radius,0+length)
        self.g.lineTo(0-radius,0)
        self.g.stroke()
        self.g.restore()
        '''
        self.g.beginPath()
        self.g.fillStyle = "red"
        self.g.font = "bold 18px sans-serif"
        self.g.fillText("%d, %d"%(self.p2.x, self.p2.y),self.p2.x, self.p2.y)
        self.g.stroke()
        '''


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    #
    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    def drawMe(self, g):
        self.g = g
        r = 5
        # 繪出三個頂點
        self.p1.drawMe(self.g,r)
        self.p2.drawMe(self.g,r)
        self.p3.drawMe(self.g,r)
        line1 = Line(self.p1,self.p2)
        line2 = Line(self.p1,self.p3)
        line3 = Line(self.p2,self.p3)
        # 繪出三邊線
        line1.drawMe(self.g)
        line2.drawMe(self.g)
        line3.drawMe(self.g)

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #&lt;CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # &lt;CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 &lt;CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp
    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

def tag(g, p):
    None

midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []
# 執行繪圖流程, 注意 x, y 為 global variables
def draw():
    global theta, midpt, oldpt
    context.clearRect(0, 0, canvas.width, canvas.height)
    line1.drawMe(context)
    line2.drawMe(context)
    line3.drawMe(context)
    #triangle1.drawMe(context)
    #triangle2.drawMe(context)
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    if theta &lt; 360:
        contour.append((tippt.x, tippt.y))
    context.beginPath()
    context.moveTo(midpt.x, midpt.y)
    context.lineTo(tippt.x, tippt.y)
    # 利用 fillRect 繪製一個長寬各 1 單位的正方形
    for i in range(len(contour)):
        context.fillRect(contour[i][0], contour[i][1], 1, 1)
    context.stroke()
    #p1.tag(context)


# 以上為相關函式物件的定義區
# 全域變數
# 幾何位置輸入變數
x=10
y=10
r=10

# 畫布與繪圖內容
# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
lift = 10
p1 =  Point(150,100+lift)
p2 =  Point(150,200+lift)
p3 =  Point(300,300+lift)
p4 =  Point(350,100+lift)

#accord position create link
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

#link2_len = line1.getR()
#link3_len = line3.getR()
#alert(str(link2_len)+','+str(link3_len))

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

# 視窗載入時執行內容
# 繪圖畫布設定

canvas = document["plotarea"]
context = canvas.getContext("2d")

# 座標轉換, 移動 canvas.height 並且 y 座標變號, 也就是將原點座標移到畫面左下角
context.translate(0,canvas.height)
context.scale(1,-1)

#以間隔 20 micro seconds 重複呼叫 draw()
timer.set_interval(draw,20)
#timer.set_interval(draw,10)
&lt;/script&gt;

&lt;br /&gt;
以下則利用多執行緒模式, 在 Leo Editor 專案中, 以按鈕執行 tkinter 視窗程式:

&lt;pre class="brush: python"&gt;
# 在 Leo Editor 專案中, 以多執行緒方式執行  tkinter 視窗程式
'''
本程式架構可以配合各種 command 執行, 納入參變數輸入進行客製化操作
'''
from tkinter import *
from tkinter import ttk
import threading

def calculate(feet, meters):
    try:
        value = float(feet.get())
        meters.set(round((0.3048 * value * 10000.0 + 0.5)/10000.0, 3))
    except ValueError:
        pass

def domake():
    root = Tk()
    root.title("Feet to Meters")

    mainframe = ttk.Frame(root, padding="3 3 12 12")
    mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
    mainframe.columnconfigure(0, weight=1)
    mainframe.rowconfigure(0, weight=1)

    feet = StringVar()
    meters = StringVar()

    feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
    feet_entry.grid(column=2, row=1, sticky=(W, E))

    ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))
    # 按鍵必須透過 lambda 傳遞輸入變數
    ttk.Button(mainframe, text="Calculate", command=lambda: calculate(feet, meters)).grid(column=3, row=3, sticky=W)

    ttk.Label(mainframe, text="feet").grid(column=3, row=1, sticky=W)
    ttk.Label(mainframe, text="is equivalent to").grid(column=1, row=2, sticky=E)
    ttk.Label(mainframe, text="meters").grid(column=3, row=2, sticky=W)

    for child in mainframe.winfo_children(): child.grid_configure(padx=5, pady=5)

    feet_entry.focus()
    root.bind('&lt;Return&gt;', calculate)

    root.mainloop()

# 利用執行緒執行 tkinter 視窗程式
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

&lt;p&gt;2014Fall CADP 二乙上課問題:&lt;/p&gt;
&lt;p&gt;何謂協同?&lt;/p&gt;
&lt;p&gt;簡言之, 協同是具備較高層次與廣度的合作, 透過同步或非同步的合作與管理系統的整合, 努力達成共同期望與目標, 也就是協力一同的意思.&lt;/p&gt;
&lt;p&gt;聯合診所多名醫生的協同:&lt;/p&gt;
&lt;p style="margin-left: 60px;"&gt;患者無論哪一時段看哪一位醫生, 都能夠得到相同且最優質的診治過程(各醫生採非同步協同), 而無需挑選特定醫師, 在特定時間與診所約診&lt;/p&gt;
&lt;p style="margin-left: 60px;"&gt;要達到此一目的, 不同醫生之間除了要能整合所有患者的基本資訊外, 還必須彼此互通有無(討論或會診), 共同學習最新技術(各醫生採同步或非同步協同), 引入最新設施, 並且體貼不同患者的客製化需求.&lt;/p&gt;
&lt;p&gt;機械設計工程師的協同:&lt;/p&gt;
&lt;p style="margin-left: 60px;"&gt;同一部門或不同部門的工程師可以彼此替代或輪班應付對內與對外的各項設計工作(各工程師採非同步協同), 要達到此一目的, 除了要有妥善的產品資料管理系統與產品生命週期管理系統外, 還需要工程師間能彼此互通有無, 共同學習最新技術(採同步或非同步)或在同一時間處理某一問題(各工程師採同步協同), 發展創新產品, 以滿足各方的客製化需求.&lt;/p&gt;
&lt;p&gt;參考資料: &lt;a href="http://www.aiim.org/What-is-Collaboration"&gt;http://www.aiim.org/What-is-Collaboration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What is Collaboration?&lt;/p&gt;
&lt;p&gt;Collaboration is a working practice whereby individuals work together to a common purpose to achieve business benefit.&lt;/p&gt;
&lt;p&gt;What is Collaboration?&lt;/p&gt;
&lt;p&gt;Collaboration enables individuals to work together to achieve a defined and common business purpose. It exists in two forms:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Synchronous, where everyone interacts in real time, as in online meetings, through instant messaging, or via Skype, and&lt;/li&gt;
&lt;li&gt;Asynchronous, where the interaction can be time-shifted, as when uploading documents or annotations to shared workspaces, or making contributions to a wiki&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Shared workspaces are among the most visible entries in the collaboration space. Aimed at rolling document and application sharing up with chat and perhaps versioning and other auditing capabilities, they may have more or fewer features, and may be available either for license or on a syndicated basis “in the cloud,” as they say. Google Docs is a notable example of the latter, Microsoft SharePoint and EMC Documentum eRoom of the former.&lt;/p&gt;
&lt;p&gt;Wikis are perhaps best thought of as online encyclopedias or “how-to” manuals. They are applications that let users freely create, edit, and reorganize content using a Web browser. Perhaps the most visible example of this breed is Wikipedia, and variants exist throughout enterprises of all kinds and sizes.&lt;/p&gt;
&lt;p&gt;The plus and the minus of wikis are that more or less anyone can enter anything into the resource – so while they’re a great way to capture and share what people know, they also must be vetted to ensure nothing erroneous gets planted within (intentionally or otherwise). The good news is that, over time, active wikis tend to be of fairly high quality due to the self-policing nature of an engaged user base.&lt;/p&gt;
&lt;p&gt;Collaboration at the conceptual level, involves:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Awareness (意識, 因知識而理解)  – We become part of a working entity with a shared purpose&lt;/li&gt;
&lt;li&gt;Motivation (動機) – We drive to gain consensus in problem solving or development&lt;/li&gt;
&lt;li&gt;Self-synchronization (主動同步)– We decide as individuals when things need to happen (與 Controlled-synchronization 相對)&lt;/li&gt;
&lt;li&gt;Participation (參與) – We participate in collaboration and we expect others to participate&lt;/li&gt;
&lt;li&gt;Mediation (調解) – We negotiate and we collaborate together and find a middle point&lt;/li&gt;
&lt;li&gt;Reciprocity (互惠)– We share and we expect sharing in return through reciprocity&lt;/li&gt;
&lt;li&gt;Reflection (反思) – We think and we consider alternatives&lt;/li&gt;
&lt;li&gt;Engagement (共識) – We proactively engage rather than wait and see&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;參考資料: &lt;a href="http://www.huffingtonpost.com/bruce-mayhew/what-is-collaboration-at-_b_5619086.html"&gt;http://www.huffingtonpost.com/bruce-mayhew/what-is-collaboration-at-_b_5619086.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Collaboration at work is both simple and challenging.&lt;/p&gt;
&lt;p&gt;Collaboration is simple when you consider collaboration requires people to work in teams as they achieve agreed upon objectives.&lt;/p&gt;
&lt;p&gt;Collaboration is challenging when you consider collaboration requires a work environment that is fundamentally different from the vertical, hierarchical structure most businesses have operated for the last 50-plus years. The work environment and business leaders must help employees with varying abilities/experience to work in flexible, dynamic teams and to respectfully share information, decision-making, responsibility, learning and recognition.&lt;/p&gt;
&lt;p&gt;To generalize about how collaboration will be viewed by employees, Baby Boomers are familiar with vertical, hierarchical business structures; most Millennials and Gen Z have grown up in collaborative team-based environments sharing decision-making, knowledge and recognition, while Gen X fall somewhere in between. Generational familiarity is very important as we consider that the number of Millennials in the workforce will soon exceed the number of Baby Boomers... and the organizations that will succeed are the organizations that are preparing now by changing reward structures and educating employees (of all ages), to work in this shared... flexible, dynamic work environment.&lt;/p&gt;
&lt;p&gt;Collaboration Requirements&lt;/p&gt;
&lt;p&gt;Senior executive support is required because collaboration and the support of high-performance teams means a change to horizontal decision-making, reporting and reward/recognition structures.&lt;/p&gt;
&lt;p&gt;5 Benefits Of A Collaborative Environment&lt;/p&gt;
&lt;p&gt;The benefits of a collaborative work environment are significant. In collaborative organizations solutions are almost always:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Faster To Market: Collaboration is a way to speed up product development without losing control or falling behind schedule.&lt;/li&gt;
&lt;li&gt;Cost Effective: More planning and agreement by stakeholders at the front end of a project means fewer mistakes and more direct routs to success.&lt;/li&gt;
&lt;li&gt;More Creative: A collaborative team environment lets every stakeholder draw on their unique talents and experience to share market-leading solutions in reference to project objective and goals.&lt;/li&gt;
&lt;li&gt;More Competitive: Collaboration is a way to get to market faster while being more responsive to customer needs.&lt;/li&gt;
&lt;li&gt;Build Customer Loyalty and Brand Value Organically: Innovative solutions that exceed customer expectations builds your brand and get your customers / prospects wanting to do business with you.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5 Barriers To A Collaborative Environment&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Employee Alignment: It's far too easy to keep doing what's been done in the past. A well-implemented, well-trained and supported team will know how to work together and how to align their efforts around the company mission and value statements.&lt;/li&gt;
&lt;li&gt;Decision Making: Collaborative team members must actively recognize it is their responsibility to come to consensus. Only if the team cannot come to agreement within the given timeframe should the Leader be expected to make a project-related decision.&lt;/li&gt;
&lt;li&gt;Documentation: Documentation of all discussions and decisions is critical. Team members not only share a purpose, they share methodology for documenting and tracking all aspects of the project.&lt;/li&gt;
&lt;li&gt;Learning As A Individual And Team Reward: Staying focused on individual and team learning is key to success. Recognition and reward comes from being connected to a successful the project.&lt;/li&gt;
&lt;li&gt;Silos: Silos encourage redundancy and sub-optimal decision-making that significantly reduce an organizations responsiveness, productivity and profitability. They can not be part of a collaborative structure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Conclusion:&lt;/p&gt;
&lt;p&gt;Collaboration is the successful structure of the future - not a single conversation between two employees. A diverse and collaborative culture is a powerful competitive advantage. A well-implemented, trained and supported high-performance team will better align their outcomes around both their objective and company mission.&lt;/p&gt;
&lt;p&gt;Tomorrows successful organizations recognize that in today's complex professional environment that collaboration is critical.&lt;/p&gt;
&lt;p&gt;Collaborative leaders recognizes there will be challenges and that their greatest responsibility is to guide change and future success by preparing their employees to overcoming these challenges in a respectful and mindful way.&lt;/p&gt;</summary><category term="Final"></category></entry><entry><title>Blue Workforce and Coppelia Robotics have merged</title><link href="./blue-workforce-and-coppelia-robotics-have-merged.html" rel="alternate"></link><published>2017-01-06T12:16:00+08:00</published><updated>2017-01-06T12:16:00+08:00</updated><author><name>yen</name></author><id>tag:,2017-01-06:./blue-workforce-and-coppelia-robotics-have-merged.html</id><summary type="html">&lt;p&gt;來自瑞士的 &lt;a href="http://www.coppeliarobotics.com/"&gt;Coppelia Robotics&lt;/a&gt; 公司已經&lt;a href="http://blueworkforce.com/uncategorized/merger-blue-workforce-acquired-coppelia-robotics-the-v-rep-company/"&gt;併入&lt;/a&gt;丹麥的 &lt;a href="http://blueworkforce.com/"&gt;Blue Workforce&lt;/a&gt; 公司.&lt;/p&gt;


&lt;p&gt;(2017.01.04)&lt;br /&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/ERD9QlouPLI" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(2016.05.28)&lt;br /&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/SM2t3wzk0ho" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(2016.07.14)&lt;br /&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/JxmNZSpmrk4" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(2016.10.10)&lt;br /&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/4NWXmyGwgpg" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;(2016.10.10)&lt;br /&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/0oOzyDPecAs" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Blue Workforce A/S, Denmark, and Coppelia Robotics GmbH, Switzerland, have merged as of December 28th, in order to pursue a shared vision on making robotics more accessible, applicable and affordable. &lt;/p&gt;
&lt;p&gt;The decision is the outcome of 3 years of intensified talks, idea sharing and mutual inspiration on how the highly innovative products and business models on both sides demonstrate the power to radically relax and improve how robotics can be conceived by both, low- and high-end users. &lt;/p&gt;
&lt;p&gt;It became clear that a merged technology assert pool unbound, was the right way to proceed with the vision we shared. &lt;/p&gt;
&lt;p&gt;Both founders, Marc Freese from Coppelia Robotics GmbH, and Preben Hjornet from Blue Workforce A/S are experienced Roboticists with a long track record of bringing innovations into the global robot industry. &lt;/p&gt;
&lt;p&gt;“to me it became clear, that the V-REP simulation tool was a 'one of a kind' and the only one which gave me confidence that I could model behavior close enough to be valid enough to give guarantees on the performance shown”. &lt;/p&gt;
&lt;p&gt;Preben continues “Once I got into direct contact with the inventor and founder of V-REP, Marc Freese, things began to move fast forward between us, on how we could merge the robotics platform of Ragnar Robotics and V-REP. &lt;/p&gt;
&lt;p&gt;Beyond the superior simulation capability, we have proven that the two together could add even more value to us and our customers as an emulation and real-time VR tracking tool. &lt;/p&gt;
&lt;p&gt;This has internally been a central part of our test, optimization and validation processes developing the Ragnar robotics”. &lt;/p&gt;
&lt;p&gt;Marc states “It is a move that was meant to happen, and I’m excited about joining with Blue Workforce, and the extended opportunities it brings“.&lt;/p&gt;
&lt;p&gt;BlueReality - Robotics system configuration purely by drag-and-drop, and configuration - no programming needed at all.&lt;/p&gt;
&lt;p&gt;The first joined contribution to the robotics industry, will be – BlueReality™ - a V-REP powered, ease-of-use, pure-configuration, robotics design, performance and feasibility study simulation VR tool-box. &lt;/p&gt;
&lt;p&gt;“We have been able to frame this so anyone with the capability to play an online computer game, also would be able to setup, run and optimize their own ideas on how to solve a robotics system” says Preben Hjornet. &lt;/p&gt;
&lt;p&gt;He adds “.. and this is just the beginning, we will shortly announce the BlueReality™ including a large pool of tutorials, and real world industrial production and packaging line scenes. &lt;/p&gt;
&lt;p&gt;BlueReality™ will radically change how you and your peers will be able to cooperate in an open framework community of open material handling robotics to down cost and short path the present over-complicated, expensive and slow path to get a robot system defined, validated, manufactured, shipped, deployed and maintained. &lt;/p&gt;
&lt;p&gt;Think about how 3D printing looked 10 years ago, and observe how the 3D printing hacker and maker community disrupted this industry. Together we will be able to lead a similar transition for the industrial robotics consumption”.&lt;/p&gt;
&lt;p&gt;Blue Workforce A/S is now the owner of Coppelia Robotics GmbH, as Marc Freese the founder and prior owner of Coppelia Robotics GmbH, has converted his ownership to a common stock shareholder position in Blue Workforce A/S. &lt;/p&gt;
&lt;p&gt;Marc Freese stays on as the general manager for Coppelia Robotics, and takes on a board position in Blue Workforce, together with CEO Blue Workforce Preben Hjørnet, VP Vestas Technology Carl Erik Skjølstrup and Chairwoman Charlotte Hjornet.&lt;/p&gt;</summary><category term="V-rep"></category></entry><entry><title>利用 Python 程式將 docx 轉為 pdf</title><link href="./li-yong-python-cheng-shi-jiang-docx-zhuan-wei-pdf.html" rel="alternate"></link><published>2016-12-09T15:00:00+08:00</published><updated>2016-12-09T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-12-09:./li-yong-python-cheng-shi-jiang-docx-zhuan-wei-pdf.html</id><summary type="html">&lt;p&gt;用來學習 Onshape 的教學檔案格式為 docx, 以下使用 Windows 環境下的 Python3 程式, 自動進入各教學檔案目錄, 將 docx 轉為 pdf&lt;/p&gt;


&lt;p&gt;首先必須以 pip install comtypes 安裝 comtypes 模組, 然後以 SciTE, 在教學檔案目錄中, 利用以下程式碼建立 docx2pdf.py 後執行, 即可將所有 56 個 docx 轉出 pdf 檔案.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import sys
import os
import comtypes.client

wdFormatPDF = 17

#in_file = input("input docx")
#out_file = input("output filename")

def docx2pdf(in_file, out_file):
    word = comtypes.client.CreateObject('Word.Application')
    doc = word.Documents.Open(in_file)
    doc.SaveAs(out_file, FileFormat=wdFormatPDF)
    doc.Close()
    word.Quit()

count = 0
# traverse root directory, and list directories as dirs and files as files
for root, dirs, files in os.walk(os.getcwd()):
    #print(root)
    path = root.split('/')
    #print(path)
    #print((len(path) - 1) * '---', os.path.basename(root))
    #print(files)
    for file in files:
        #print(len(path) * '---', file)
        file_ext = file.split(".")[1]
        file_name = file.split(".")[0]
        #print(file_ext)
        if file_ext == "docx":
            count = count + 1
            in_file = path[0] + "/" + file
            #print(count,":", in_file)
            out_file = path[0] + "/" + file_name + ".pdf"
            #print(out_file)
            docx2pdf(in_file, out_file)

#print(count)
#docx2pdf(in_file, out_file)
print("done")
&lt;/pre&gt;</summary><category term="使用導引"></category><category term="docx"></category><category term="pdf"></category></entry><entry><title>利用 Git submodule 功能進行組員資料設計整合</title><link href="./li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html" rel="alternate"></link><published>2016-11-24T15:00:00+08:00</published><updated>2016-11-24T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-24:./li-yong-git-submodule-gong-neng-jin-xing-zu-yuan-zi-liao-she-ji-zheng-he.html</id><summary type="html">&lt;p&gt;電腦輔助設計流程中, 利用 git submodule 指令, 可以整合組員所提供的設計資料、設計程式與設計零組件.&lt;/p&gt;


&lt;p&gt;引用子模組中的四連桿繞行軌跡點座標資料, 進行繪圖的範例: &lt;a href="https://scrum-1.github.io/2016fallcadp_ag100/blog/git-submodule-zai-dian-nao-fu-zhu-she-ji-shang-de-ying-yong.html"&gt;https://scrum-1.github.io/2016fallcadp_ag100/blog/git-submodule-zai-dian-nao-fu-zhu-she-ji-shang-de-ying-yong.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;引用組員設計程式的範例:&lt;/p&gt;
&lt;p&gt;引用組員的設計零組件範例:&lt;/p&gt;
&lt;p&gt;利用 github 所提供的 stl 零件格式展示, 或 Solvespace 的零件 .js 格式, 將組員分別完成的 OnShape 課程零組件, 透過子模組設定, 展示在各分組的網誌中.&lt;/p&gt;</summary><category term="使用導引"></category><category term="Brython"></category><category term="git"></category><category term="submodule"></category></entry><entry><title>Brython 動畫測試</title><link href="./brython-dong-hua-ce-shi.html" rel="alternate"></link><published>2016-11-20T15:00:00+08:00</published><updated>2016-11-20T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-20:./brython-dong-hua-ce-shi.html</id><summary type="html">&lt;p&gt;Brython 動畫測試&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 
以下實際利用  Brython 執行繪圖 
程式來源: http://stackoverflow.com/questions/39689555/simple-image-rotation-with-python-and-dom-using-rapydscript
--&gt;

&lt;script type='text/python3'&gt;
from browser import window, timer, document, html
import time

t0 = time.time()

def user_agent():
   """ Helper function for determining the user agent """
   if window.navigator.userAgent.find('Chrome'):
       return 'chrome'
   elif window.navigator.userAgent.find('Firefox'):
       return 'firefox'
   elif window.navigator.userAgent.find('MSIE'):
       return 'msie'
   elif window.navigator.userAgent.find('Opera'):
       return 'opera'

# Dict Mapping UserAgents to Transform Property names
# 在不同的瀏覽器, 有不同的 transform 名稱
rotate_property = {
   'chrome':'WebkitTransform',
   'firefox':'MozTransform',
   'msie':'msTransform',
   'opera':'OTransform'
}

degrees = 0
def animation_step(elem_id):
   """ Called every 30msec to increase the rotatation of the element. """
   global degrees, tm

   # Get the right property name according to the useragent
   agent = user_agent()
   prop = rotate_property.get(agent,'transform')

   # Get the element by id
   el = document[elem_id]

   # Set the rotation of the element
   # 設定 element 的旋轉屬性
   setattr(el.style, prop, "rotate("+str(degrees)+"deg)")
   # 將旋轉角度寫在 id 為 status 的區域
   document['status'].innerHTML = "rotate("+str(degrees)+" deg)"

   # Increase the rotation
   degrees += 1
   if degrees &gt; 360:
       # Stops the animation after 360 steps
       timer.clear_interval(tm)
       degrees = 0

# Start the animation
# 每 30 msec 重新刷新繪圖
tm = timer.set_interval(lambda id='img1':animation_step(id), 30)
# 將執行所花費時間, 寫在 id="status3" 的標註區域
document['status3'].innerHTML = "執行所花費時間: ("+str(time.time()-t0)+" ms)"

&lt;/script&gt;

&lt;!-- 以下利用 img 標註, 選擇位於 data 目錄下的 png 圖檔 --&gt;

&lt;p&gt;&lt;img id="img1" src="./../data/guitar_chord.png" alt="cog1"&gt;
&lt;div id="status"&gt;&lt;/div&gt;
&lt;div id="status3"&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="使用導引"></category><category term="Brython"></category></entry><entry><title>2016Fall 期中摘要</title><link href="./2016fall-qi-zhong-zhai-yao.html" rel="alternate"></link><published>2016-11-17T15:00:00+08:00</published><updated>2016-11-17T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-17:./2016fall-qi-zhong-zhai-yao.html</id><summary type="html">&lt;p&gt;經過 9 個禮拜, 電腦輔助設計實習課程到底學到什麼?&lt;/p&gt;


&lt;h2&gt;沒有 OpenShift 與 copy.com 之後&lt;/h2&gt;
&lt;p&gt;首先必須說明的是, 本課程在 2016 Fall, 為了因應 OpenShift 無法提供每一個學員免費雲端空間, 而且 copy.com 也終止服務之後, 從電腦輔助設計實習走向協同產品設計實習, 只剩下 Github 以及自己架設的伺服器. 因此本學期的所有教學運作全部在 Github 平台上執行, 每一位學員都必須申請 Github 帳號, 並且利用 html5 以及 Javascript 來維護自己倉儲中 gh-pages 分支上的資料.&lt;/p&gt;
&lt;p&gt;面對這樣的轉變, 在目前這個 Leo Editor 專案中, 特別建立了一個近端的 https 伺服器按鈕, 而且為了能夠獨立於 Leo Editor 運作, 特別採用執行緒的架構編寫:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 8443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("8443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

&lt;p&gt;使用者只要將滑鼠停在 https-server 按鈕所在節點, 然後按下 Leo Editor 上方的對應按鈕, 就可以在近端電腦上執行一個 https 伺服器, 啟動之後, 只要利用瀏覽器連結 https://localhost:8443, 就可以得到與 Github pages 上相同的執行結果.&lt;/p&gt;
&lt;p&gt;儘管在這個 https 伺服器中只能運行 html5 與 Javascript, 但是為了配合計算機程式的 Python3, 電腦輔助設計實習並不直接讓學員編寫 Javascript, 而是透過 Brython 執行網頁上的 Python3 格式程式, 本學期主要透過 html5 中的 canvas 繪圖來模擬平面多連桿機構的運動, 並且利用 Solvespace 與 OnShape 結合 V-rep 進行驗證, 當然最終理想, 是可以將平面多連桿機構以 3D 印表機列印出零組件, 然後透過步進馬達驅動, 讓學員有機會接觸機電資 (InfoRmechAtronic) 整合的實習.&lt;/p&gt;
&lt;p&gt;另外, 由於 2016 Fall CADP 課程規劃為一個全新的內容組合, 從 Github Pages 的網誌搭建作為開端, reveal.js 的網際投影片作為輔助簡報, 至於 Github Wiki 則充當數位筆記本, 專門用來收集零碎的參考資料.&lt;/p&gt;
&lt;p&gt;上述 Pelican 網誌、reveal.js 簡報與 Github Wiki 其實有許多重複的展示資料, 原本可以透過 Leo Editor 的 clone node 與 Github 的 &lt;a href="https://help.github.com/articles/adding-and-editing-wiki-pages-locally/"&gt;本地 wiki 維護&lt;/a&gt; 說明, 統一整合在 Leo Editor 專案中, 但是需要 @clean 與 @others 以及命名節點等進階 Leo 指令的導入, 目前尚未納入課程.&lt;/p&gt;
&lt;h2&gt;Git submodule 的應用&lt;/h2&gt;
&lt;p&gt;這個學期首度在 CADP 課程中導入 git submodule, 主要是為了配合協同設計流程中的模擬程式呼叫, 讓組員間可以透過子模組的架構, 決定程式與設計資料的版次後, 彼此引用協同資料. 只是目前採用全班分組子模組的架構, 只要一個組員設定出錯, 全班的 gh-pages 網頁就無法更新, 因此從第 11 週起, 將改為組員自行建立子模組的程式與資料協同, 然後擴充到各組, 若各組運作正常, 待協同產品設計實習課程階段, 再推展到班級子模組協同.&lt;/p&gt;
&lt;p&gt;最後, 本課程網誌前面各筆資料的大架構雖然已經決定, 但是執行細節與範圍仍然必須配合學員的學習結果, 再逐一放入內容, 因此, 各筆資料在課程結束之前, 將會持續更新.&lt;/p&gt;</summary><category term="使用導引"></category><category term="期中"></category></entry><entry><title>2016Fall Delta 3D 印表機設計</title><link href="./2016fall-delta-3d-yin-biao-ji-she-ji.html" rel="alternate"></link><published>2016-11-06T15:00:00+08:00</published><updated>2016-11-06T15:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-delta-3d-yin-biao-ji-she-ji.html</id><summary type="html">&lt;p&gt;各組自行透過 &lt;a href="http://tw.misumi-ec.com/"&gt;http://tw.misumi-ec.com/&lt;/a&gt; 尋找適用的標準零件, 下載 2D 與 3D 零件圖檔, 利用 Solvespace 與 OnShape 進行設計組立與模擬後, 實際下單購買各零組件, 完成 3D 印表機的設計與實作.&lt;/p&gt;


&lt;p&gt;W14 週零件採購&lt;/p&gt;
&lt;p&gt;W15 Delta 3D Printer in Solvespace:&lt;/p&gt;
&lt;p&gt;&lt;img src="../data/w15/solvespace_printer.png" width="600" /&gt;&lt;/p&gt;
&lt;iframe src="./../data/threejs/delta_in_solvespace.html" width="600" height="400"&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://github.com/mdecourse/2016fallcadp/blob/gh-pages/course/delta_printer_v2.7z"&gt;Delta 3D Printer in Solvespace 零組件檔案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W15 Delta 3D Printer in Onshape:&lt;/p&gt;
&lt;p&gt;&lt;img src="../data/w15/onshape_printer.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://cad.onshape.com/documents/5857da172c6401109cd59c40/w/3c12983596f0b655e19c8242/e/acc3c9a33b806c014834c490"&gt;Delta 3D Printer in Onshape 零組件檔案&lt;/a&gt;&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall Onshape 教學</title><link href="./2016fall-onshape-jiao-xue.html" rel="alternate"></link><published>2016-11-06T14:00:00+08:00</published><updated>2016-11-06T14:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-onshape-jiao-xue.html</id><summary type="html">&lt;p&gt;有關 Onshape 零件, 組件, 機構模擬等功能介紹, FeatureScript 與協同設計等&lt;/p&gt;


&lt;p&gt;各組以每週完成 3 個 weeks 的 Onshape 標準 College Curriculum 教材後, 根據 &lt;a href="http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf"&gt;http://chiamingyen.github.io/kmolab_data/files/ProEMechanism.pdf&lt;/a&gt; 說明完成零件繪製與組立後,  如何精確得知機構運動過程的約束位置?&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall 平面機構模擬</title><link href="./2016fall-ping-mian-ji-gou-mo-ni.html" rel="alternate"></link><published>2016-11-06T13:00:00+08:00</published><updated>2016-11-06T13:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-ping-mian-ji-gou-mo-ni.html</id><summary type="html">&lt;p&gt;有關 Solvespace 機構模擬功能介紹, 與 Python3 及 Brython 程式驗證&lt;/p&gt;


&lt;h2&gt;Solvespace 平面四連桿機構模擬&lt;/h2&gt;
&lt;p&gt;直接利用 Solvespace Analyze-Trace Point-Stop Trace 得到下列繞行路徑:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/cadpa_w10_4bar.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;將所得到的點座標 .csv 以 Excel 畫圖, 得到:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/cadpa_w10_4bar_excel.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Python3 平面四連桿機構模擬:&lt;/p&gt;
&lt;p&gt;接下來利用三角函數推導四連桿機構的運動模擬, 即已知長度 18 公分的連桿以逆時針方向旋轉, 希望求三角形頂點的運動座標.&lt;/p&gt;
&lt;p&gt;首先利用 Brython, 讀取 data 目錄中的 cadpa_w10_4bar.csv 座標檔案, 然後以 splitlines() 及 split() 取出各點的 x 座標與 y 座標後, 將點連成路徑曲線如下:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下實際利用  Brython 畫兩條直線 --&gt;

&lt;canvas id="fourbar" width="600" height="400"&gt;&lt;/canvas&gt;

&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
from browser import html
import math
# 準備繪圖畫布
canvas = doc["fourbar"]
container1 = doc['container1']
ctx = canvas.getContext("2d")

fourbar_data = open("./../data/cadpa_w10_4bar.csv").read()
fourbar_list = fourbar_data.splitlines()
#container1 &lt;= fourbar_list[0]
# 以下可以利用 ctx 物件進行畫圖
# 先畫一條直線
ctx.beginPath()
# 設定線的寬度為 1 個單位
ctx.lineWidth = 1
# 利用 transform 將 y 座標反轉, 且 offset canvas.height
# (X scale, X skew, Y skew, Y scale, X offset, Y offset)
# 配合圖形位置進行座標轉換
ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100)
# 畫出 x 與 y 座標線
# 各座標值放大 8 倍
ratio = 8
'''
ctx.moveTo(0, 0)
ctx.lineTo(0, 100)
ctx.moveTo(0, 0)
ctx.lineTo(100, 0)
'''
ctx.moveTo(0, 0)
ctx.lineTo(-30*ratio, 0)
start_point = fourbar_list[0].split(",")
ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio)
count = 0
for data in fourbar_list[1:]:
    point = data.split(",")
    #count = count + 1
    #container1 &lt;= str(count) + ":" + point[0] + "," + point[1]
    #container1 &lt;= html.BR()
    ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio)
# 設定顏色為藍色, 也可以使用 "rgb(0, 0, 255)" 字串設定顏色值
ctx.strokeStyle = "blue"
# 實際執行畫線
ctx.stroke()
ctx.closePath()
&lt;/script&gt;

&lt;p&gt;Ubuntu 安裝 matplotlib:&lt;/p&gt;
&lt;p&gt;sudo apt-get install python3-matplotlib&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import math
import time
# 利用 matplotlib 程式庫畫出 contour 輪廓
import matplotlib.pyplot as plt

class Coord(object):
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __sub__(self,other):
        # This allows you to substract vectors
        return Coord(self.x-other.x,self.y-other.y)

    def __repr__(self):
        # Used to get human readable coordinates when printing
        return "Coord(%f,%f)"%(self.x,self.y)

    def length(self):
        # Returns the length of the vector
        return math.sqrt(self.x**2 + self.y**2)

    def angle(self):
        # Returns the vector's angle
        return math.atan2(self.y,self.x)

def normalize(coord):
    return Coord(
        coord.x/coord.length(),
        coord.y/coord.length()
        )

def perpendicular(coord):
    # Shifts the angle by pi/2 and calculate the coordinates
    # using the original vector length
    return Coord(
        coord.length()*math.cos(coord.angle()+math.pi/2),
        coord.length()*math.sin(coord.angle()+math.pi/2)
        )


# 點類別
class Point(object):
    # 起始方法
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # 加入 Eq 方法
    def Eq(self, pt):
        self.x = pt.x
        self.y = pt.y

    # 加入 setPoint 方法
    def setPoint(self, px, py):
        self.x = px
        self.y = py

    # 加上 distance(pt) 方法, 計算點到 pt 的距離
    def distance(self, pt):
        self.pt = pt
        x = self.x - self.pt.x
        y = self.y - self.pt.y
        return math.sqrt(x * x + y * y)


# Line 類別物件
class Line(object):

    # 起始方法
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        # 直線的第一點, 設為線尾
        self.Tail = self.p1
        # 直線組成的第二點, 設為線頭
        self.Head = self.p2
        # 直線的長度屬性
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setPP 以指定頭尾座標點來定義直線
    def setPP(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.Tail = self.p1
        self.Head = self.p2
        self.length = math.sqrt(math.pow(self.p2.x-self.p1.x, 2)+math.pow(self.p2.y-self.p1.y,2))

    # setRT 方法 for Line, 應該已經確定 Tail 點, 然後以 r, t 作為設定 Head 的參考
    def setRT(self, r, t):
        self.r = r
        self.t = t
        x = self.r * math.cos(self.t)
        y = self.r * math.sin(self.t)
        self.Tail.Eq(self.p1)
        self.Head.setPoint(self.Tail.x + x,self.Tail.y + y)

    # getR 方法 for Line
    def getR(self):
        # x 分量與 y 分量
        x = self.p1.x - self.p2.x
        y = self.p1.y - self.p2.y
        return math.sqrt(x * x + y * y)

    # 根據定義 atan2(y,x), 表示 (x,y) 與 正 x 軸之間的夾角, 介於 pi 與 -pi 間
    def getT(self):
        x = self.p2.x - self.p1.x
        y = self.p2.y - self.p1.y
        if (math.fabs(x) &lt; math.pow(10,-100)):
            if(y &lt; 0.0):
                return (-math.pi/2)
            else:
                return (math.pi/2)
        else:
            return math.atan2(y, x)

    # setTail 方法 for Line
    def setTail(self, pt):
        self.pt = pt
        self.Tail.Eq(pt)
        self.Head.setPoint(self.pt.x + self.x, self.pt.y + self.y)

    # getHead 方法 for Line
    def getHead(self):
        return self.Head

    def getTail(self):
        return self.Tail


class Link(Line):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.length = math.sqrt(math.pow((self.p2.x - self.p1.x), 2) + math.pow((self.p2.y - self.p1.y), 2))


class Triangle(object):
    def __init__(self, p1, p2, p3):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3

    def getLenp3(self):
        p1 = self.p1
        ret = p1.distance(self.p2)
        return ret

    def getLenp1(self):
        p2 = self.p2
        ret = p2.distance(self.p3)
        return ret

    def getLenp2(self):
        p1 = self.p1
        ret = p1.distance(self.p3)
        return ret

    # 角度
    def getAp1(self):
        ret = math.acos(((self.getLenp2() * self.getLenp2() + self.getLenp3() * self.getLenp3()) - self.getLenp1() * self.getLenp1()) / (2* self.getLenp2() * self.getLenp3()))
        return ret

    def getAp2(self):
        ret =math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp3() * self.getLenp3()) - self.getLenp2() * self.getLenp2()) / (2* self.getLenp1() * self.getLenp3()))
        return ret

    def getAp3(self):
        ret = math.acos(((self.getLenp1() * self.getLenp1() + self.getLenp2() * self.getLenp2()) - self.getLenp3() * self.getLenp3()) / (2* self.getLenp1() * self.getLenp2()))
        return ret

    # ends Triangle def
    # 透過三個邊長定義三角形
    def setSSS(self, lenp3, lenp1, lenp2):
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        self.lenp2 = lenp2
        self.ap1 = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2* self.lenp2 * self.lenp3))
        self.ap2 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2* self.lenp1 * self.lenp3))
        self.ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2* self.lenp1 * self.lenp2))

    # 透過兩個邊長與夾角定義三角形
    def setSAS(self, lenp3, ap2, lenp1):
        self.lenp3 = lenp3
        self.ap2 = ap2
        self.lenp1 = lenp1
        self.lenp2 = math.sqrt((self.lenp3 * self.lenp3 + self.lenp1 * self.lenp1) - 2* self.lenp3 * self.lenp1 * math.cos(self.ap2))
        #等於 SSS(AB, BC, CA)

    def setSaSS(self, lenp2, lenp3, lenp1):
        self.lenp2 = lenp2
        self.lenp3 = lenp3
        self.lenp1 = lenp1
        if(self.lenp1 &gt; (self.lenp2 + self.lenp3)):
        #CAB 夾角為 180 度, 三點共線且 A 介於 BC 之間
            ret = math.pi
        else :
            # CAB 夾角為 0, 三點共線且 A 不在 BC 之間
            if((self.lenp1 &lt; (self.lenp2 - self.lenp3)) or (self.lenp1 &lt; (self.lenp3 - self.lenp2))):
                ret = 0.0
            else :
            # 透過餘絃定理求出夾角 CAB 
                ret = math.acos(((self.lenp2 * self.lenp2 + self.lenp3 * self.lenp3) - self.lenp1 * self.lenp1) / (2 * self.lenp2 * self.lenp3))
        return ret

    # 取得三角形的三個邊長值
    def getSSS(self):
        temp = []
        temp.append( self.getLenp1() )
        temp.append( self.getLenp2() )
        temp.append( self.getLenp3() )
        return temp

    # 取得三角形的三個角度值
    def getAAA(self):
        temp = []
        temp.append( self.getAp1() )
        temp.append( self.getAp2() )
        temp.append( self.getAp3() )
        return temp

    # 取得三角形的三個角度與三個邊長
    def getASASAS(self):
        temp = []
        temp.append(self.getAp1())
        temp.append(self.getLenp1())
        temp.append(self.getAp2())
        temp.append(self.getLenp2())
        temp.append(self.getAp3())
        temp.append(self.getLenp3())
        return temp

    #2P 2L return mid P
    def setPPSS(self, p1, p3, lenp1, lenp3):
        temp = []
        self.p1 = p1
        self.p3 = p3
        self.lenp1 = lenp1
        self.lenp3 = lenp3

        #bp3 is the angle beside p3 point, cp3 is the angle for line23, p2 is the output
        line31 = Line(p3, p1)
        self.lenp2 = line31.getR()
        #self.lenp2 = self.p3.distance(self.p1)
        #這裡是求角3
        ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp2 * self.lenp2) - self.lenp3 * self.lenp3) / (2 * self.lenp1 * self.lenp2))
        #ap3 = math.acos(((self.lenp1 * self.lenp1 + self.lenp3 * self.lenp3) - self.lenp2 * self.lenp2) / (2 * self.lenp1 * self.lenp3))
        bp3 = line31.getT()
        cp3 = bp3 - ap3
        temp.append(p3.x + self.lenp1*math.cos(cp3))#p2.x
        temp.append(p3.y + self.lenp1*math.sin(cp3))#p2.y
        return temp

# 以上為相關函式物件的定義區
# 全域變數
midpt = Point(0, 0)
tippt = Point(0, 0)
contour = []

# 幾何位置輸入變數
x=10
y=10
r=10

# 其他輸入變數
theta = 0
degree = math.pi/180.0
dx = 2
dy = 4

#set p1.p2.p3.p4 position
p1 =  Point(150,100)
p2 =  Point(150,200)
p3 =  Point(300,300)
p4 =  Point(350,100)

#create links
line1 =  Link(p1,p2)
line2 =  Link(p2,p3)
line3 =  Link(p3,p4)
line4 =  Link(p1,p4)
line5 =  Link(p2,p4)

link2_len = p2.distance(p3)
link3_len = p3.distance(p4)

triangle1 =  Triangle(p1,p2,p4)
triangle2 =  Triangle(p2,p3,p4)

def simulate():
    global theta, midpt, oldpt
    theta += dx
    p2.x = p1.x + line1.length*math.cos(theta*degree)
    p2.y = p1.y - line1.length*math.sin(theta*degree)
    p3.x, p3.y = triangle2.setPPSS(p2,p4,link2_len,link3_len)
    # 計算垂直單位向量
    a = Coord(p3.x, p3.y)
    b = Coord(p2.x, p2.y)
    normal = perpendicular(normalize(a-b))
    midpt.x = (p2.x + p3.x)/2
    midpt.y = (p2.y + p3.y)/2
    tippt.x = midpt.x + 150*normal.x
    tippt.y = midpt.y + 150*normal.y
    # 印出座標點
    #print(round(tippt.x, 2), round(tippt.y, 2))
    if theta &lt; 360:
        contour.append((round(tippt.x, 2), round(tippt.y, 2)))

for i in range(180):
    simulate()
# 印出 contour 
#print(contour)

x_list = [x for (x, y) in contour]
y_list = [y for (x, y) in contour]

plt.xlabel('x coordinate')
plt.ylabel('y coordinate')

plt.plot(x_list, y_list)
plt.show()
&lt;/pre&gt;

&lt;p&gt;以下將上述四連桿模擬程式移到近端的 Jupyter 平台中執行:&lt;/p&gt;
&lt;p&gt;以下將上述四連桿模擬程式移到 Jupyterhub 平台中執行:&lt;/p&gt;
&lt;p&gt;以下再利用 Brython 繪出四連桿模擬特定點的掃掠圖:&lt;/p&gt;
&lt;p&gt;以下利用 Brython 動態畫出四連桿機構模擬圖:&lt;/p&gt;
&lt;p&gt;以下利用 Solvespace 繪圖法進行相同機構模擬驗證:&lt;/p&gt;
&lt;p&gt;以下再利用 Solvespace 程式 API 方法進行四連桿模擬驗證:&lt;/p&gt;
&lt;p&gt;以下以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;以下利用伸縮連桿設計, 以 Delta 3D 印表機印出連桿零件, 組立後以步進馬達驅動進行驗證:&lt;/p&gt;
&lt;p&gt;請以上述相同流程, 模擬並實作驗證 &lt;a href="http://solvespace.com/linkage.pl"&gt;多連桿機構&lt;/a&gt;的作動.&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall Solvespace 教學</title><link href="./2016fall-solvespace-jiao-xue.html" rel="alternate"></link><published>2016-11-06T12:00:00+08:00</published><updated>2016-11-06T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-solvespace-jiao-xue.html</id><summary type="html">&lt;p&gt;有關 Solvespace 零件, 組件, 機構模擬等功能介紹, 程式編譯與 API 延伸等&lt;/p&gt;


&lt;h2&gt;Solvespace&lt;/h2&gt;
&lt;h3&gt;1. Parts (零件繪製)&lt;/h3&gt;
&lt;p&gt;範例檔案: &lt;a href="http://solvespace.com/bracket.pl"&gt;http://solvespace.com/bracket.pl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;An introductory tutorial is available, in which we draw the same part that is shown in the demo video. &lt;/p&gt;
&lt;p&gt;This covers most of the basic features of SolveSpace, including sketches, constraints, extrusions, and Boolean operations.&lt;/p&gt;
&lt;p&gt;When we first run SolveSpace, we will begin with an empty part. Initially, our view of the part will be oriented onto the XY plane; the label for that plane is displayed at the bottom left of the screen (#XY, in dark grey). The axes are also indicated by the three colored arrows at the bottom left; the X, Y, and Z axes are drawn in red, green, and blue respectively.&lt;/p&gt;
&lt;p&gt;When we hover the mouse over any entity, constraint, or other object in the sketch, that object will appear highlighted in yellow. For example, the XY plane, which is drawn as a dashed square, will appear highlighted when we hover the mouse over it. The YZ and ZX planes initially look like dashed lines, because they are being viewed on edge; but they still appear highlighted in yellow when we hold the mouse over them. It is similarly possible to highlight the X, Y, and Z axes (which are drawn as arrows), or the origin (which like all points is drawn as a green square).&lt;/p&gt;
&lt;h4&gt;Extrude (平行長出或除料)&lt;/h4&gt;
&lt;h4&gt;Lathe (旋轉繞行長出或除料)&lt;/h4&gt;
&lt;h4&gt;零組件繪圖練習&lt;/h4&gt;
&lt;p&gt;利用 Solvespace, 以 &lt;a href="./../data/w12/College_Student_Primer_Creo_2.pdf"&gt;College_Student_Primer_Creo_2.pdf&lt;/a&gt; 為範本, 編寫一本 Solvespace 零組件導引 pdf 手冊.&lt;/p&gt;
&lt;p&gt;利用 .md 檔案格式編寫, 建立導引手冊所需的圖文資料後, 設法利用 Pandoc 與 LaTeX 轉為 html 與 pdf 檔案.&lt;/p&gt;
&lt;p&gt;首先必須設法編譯 Solvespace 原始碼, 取得 Windows 10 64 位元與 Ubuntu 16.04 64 位元環境下執行的 solvespace.exe 與 solvespace.&lt;/p&gt;
&lt;p&gt;啟動 Solvespace 後, 在 View 功能表下確定所使用的尺寸單位, 選擇 mm 作為繪圖單位.&lt;/p&gt;
&lt;p&gt;根據尺寸繪製一個 block.&lt;/p&gt;
&lt;h4&gt;Export Triangle Mesh&lt;/h4&gt;
&lt;p&gt;STL 格式&lt;/p&gt;
&lt;p&gt;將零件檔案轉出 STL 格式後 (binary or ASCII format definitions), 進入倉儲後, 利用 &lt;a href="https://help.github.com/articles/3d-file-viewer/"&gt;Github 內建的 stl viewer 功能&lt;/a&gt;展示.&lt;/p&gt;
&lt;p&gt;three.js&lt;/p&gt;
&lt;iframe src="./../data/threejs/donut.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="./../data/w12/College_Student_Primer_Creo_2.pdf"&gt;W12 組立&lt;/a&gt;&lt;/p&gt;
&lt;iframe src="./../data/threejs/w12.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;iframe src="./../data/threejs/w12b.html" width="800" height="600"&gt;&lt;/iframe&gt;

&lt;h3&gt;2. Assembly (零件組立)&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://solvespace.com/box.pl"&gt;http://solvespace.com/box.pl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To start, we would like to define the orientation of the part. We can do that by locking one of the part's normals in the same orientation as one of our coordinate axes. Here, a good choice would be to constrain any of the base's normals—which are drawn as blue arrows—in the same orientation as our coordinate system's Z axis, which is also drawn as a blue arrow, in this view pointing approximately up from the origin. Select those two normals by left-clicking them, and choose Constrain → Same Orientation, or the equivalent constraint from the toolbar.&lt;/p&gt;
&lt;p&gt;The two normals are now each marked with a magenta X, which is visible above. (It doesn't matter which of the normals on the part were chosen to constrain, since they all point in the same direction. The choice is arbitrary.) This means that those two normals are constrained to point in the same direction (i.e., parallel); but it also locks the twist of the part about that axis, so it fully constrains the part's orientation. The same-orientation constraint is useful, because it completely specifies a part's orientation with a single constraint.&lt;/p&gt;
&lt;p&gt;We can try to drag the part's orientation and rotation now. We will find that it is still possible to translate the part anywhere, but impossible to rotate it, because that rotation is now fixed. To define the translation, we can use a point-coincident constraint. Select the two points marked in red in the image above, and choose Constrain → On Point. The two points will now be constrained to be coincident, locking the imported part's translation. The imported part is now fully constrained.&lt;/p&gt;
&lt;h3&gt;3. Linkages (fourbar &amp;amp; multilink) (四連桿與多連桿運動模擬)&lt;/h3&gt;
&lt;p&gt;四連桿:&lt;/p&gt;
&lt;p&gt;利用線架構完成四連桿模擬後, 將 3D 零件以點重合, 點在面與點在線上約束各連桿後完成.&lt;/p&gt;
&lt;p&gt;多連桿:  &lt;a href="http://solvespace.com/linkage.pl"&gt;http://solvespace.com/linkage.pl&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4. Compiled &amp;amp; API (編譯與延伸應用)&lt;/h3&gt;
&lt;p&gt;使用 Virtualbox 虛擬主機執行 Windows 64 位元與 Ubuntu 64 位元環境中的編譯與延伸應用.&lt;/p&gt;
&lt;p&gt;Virtualbox Ubuntu 64位元虛擬檔案: &lt;a href="http://140.130.17.17/public/Ubuntu/1604_solvespace_final/Ubuntu_160464.vdi"&gt;http://140.130.17.17/public/Ubuntu/1604_solvespace_final/Ubuntu_160464.vdi&lt;/a&gt; (只有在區網可以下載)&lt;/p&gt;
&lt;p&gt;在虛擬主機中完成 Solvespace 編譯與執行的參考畫面:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/solvespace/cadpa_w11_solvespace_compiled.png" width="800" /&gt;&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry><entry><title>2016Fall 機械設計主題教學</title><link href="./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html" rel="alternate"></link><published>2016-11-06T11:00:00+08:00</published><updated>2016-11-06T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:,2016-11-06:./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html</id><summary type="html">&lt;p&gt;知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能.&lt;/p&gt;


&lt;h1&gt;機械設計主題教學&lt;/h1&gt;
&lt;p&gt;創造力三元素, 機械設計的六種表達, 協同設計的四大面向.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;強化創造能力 - 自學力、程式力與想像力
(Creative Competencies)&lt;/li&gt;
&lt;li&gt;熟習六種表達  - 口語、文字、2D、3D、理論與實體表達
(Six Presentation Methods)&lt;/li&gt;
&lt;li&gt;融入協同設計 - 電腦、網路、軟硬體工具與協同專案
(Collaborative Designs)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2016 Fall CADP 課程資料檢視:&lt;/p&gt;
&lt;p&gt;將要以 Brython 讀取兩班修課名單與分組名單, 並根據作業倉儲規劃, &lt;/p&gt;
&lt;p&gt;以各班 submodule 分組檢視 (必須各組與各成員 submodule 設置正確):&lt;/p&gt;
&lt;p&gt;各成員 submodule 架構檢視 (必須各組與各成員 submodule 設置正確):&lt;/p&gt;
&lt;p&gt;各班各組直接檢視:&lt;/p&gt;
&lt;p&gt;電腦輔助設計實習甲班成員連結:&lt;/p&gt;
&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;!-- &lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/master/www/src/brython_dist.js"&gt; --&gt;

&lt;script type="text/javascript" 
    src="https://cdn.rawgit.com/brython-dev/brython/3.2.9/www/src/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
brython(1);
}
&lt;/script&gt;

&lt;!-- 以下利用 Brython 程式執行檔案讀取與比對流程 --&gt;

&lt;!-- 假如需要用圖型表示數字, 則利用 canvas 繪圖 --&gt;

&lt;!-- &lt;canvas id="plotarea" width="600" height="400"&gt;&lt;/canvas&gt; --&gt;

&lt;p&gt;甲班學員投影片:&lt;/p&gt;
&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script1"&gt;
from browser import document, html
container1 = document['container1']
adata = open("./../users/a.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://"+str(stud_num)+".github.io/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container1 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員網誌:&lt;/p&gt;
&lt;div id="container2"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script2"&gt;
from browser import document, html
from script1 import alist
container2 = document['container2']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://"+str(stud_num)+".github.io/2016fallcadp_hw/blog")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container2 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員 wiki:&lt;/p&gt;
&lt;div id="container3"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script3"&gt;
from browser import document, html
from script1 import alist
container3 = document['container3']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://github.com/"+str(stud_num)+"/2016fallcadp_hw/wiki")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container3 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
甲班學員倉儲:&lt;/p&gt;
&lt;div id="container4"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script4"&gt;
from browser import document, html
from script1 import alist
container4 = document['container4']
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://github.com/"+str(stud_num)+"/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container4 &lt;= mlink
&lt;/script&gt;

&lt;hr&gt;

&lt;p&gt;乙班學員投影片:&lt;/p&gt;
&lt;div id="container5"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script5"&gt;
from browser import document, html
container5 = document['container5']
adata = open("./../users/b.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://"+str(for_link)+".github.io/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container5 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員網誌:&lt;/p&gt;
&lt;div id="container6"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script6"&gt;
from browser import document, html
from script5 import alist
container6 = document['container6']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://"+str(for_link)+".github.io/2016fallcadp_hw/blog")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container6 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員 wiki:&lt;/p&gt;
&lt;div id="container7"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script7"&gt;
from browser import document, html
from script5 import alist
container7 = document['container7']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://github.com/"+str(for_link)+"/2016fallcadp_hw/wiki")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container7 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
乙班學員倉儲:&lt;/p&gt;
&lt;div id="container8"&gt;&lt;/div&gt;

&lt;script type="text/python3" id="script8"&gt;
from browser import document, html
from script5 import alist
container8 = document['container8']
n = 0
for stud_num in alist:
    # 請注意, 這裡有例外 40223206 前頭必須加上 s
    # 40423239 前頭必須加上 a
    # 40423207 則之後要加上 7
    if stud_num == '40223206':
        for_link = "s" + stud_num
    elif stud_num == '40423239':
        for_link = "a" + stud_num
    elif stud_num == '40423207':
        for_link  = stud_num +"7"
    else:
        for_link = stud_num
    mlink = html.A(stud_num, href="http://github.com/"+str(for_link)+"/2016fallcadp_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container8 &lt;= mlink
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;
各班各組成員 submodule 架構檢視 (必須各組 submodule 設置正確:&lt;/p&gt;
&lt;p&gt;各成員直接檢視:&lt;/p&gt;
&lt;p&gt;以下為分組資料處理程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
content = open("2016fall_cadp_a_groups.txt").read()
#print(content)
result = content.splitlines()
#print(result)
gno = 1
for i in range(len(result)):
    #print(result[i])
    group = result[i].split(":")
    #列出組序
    print("&amp;lt;a href='../g"+str(gno)+"'&amp;gt;第"+str(gno)+"組&amp;lt;/a&amp;gt;:&amp;lt;br /&amp;gt;")
    #print("第"+str(gno)+"組:&amp;lt;br /&amp;gt;")
    #取 group 第2成員, 用逗點隔開納入數列後, 利用[:-1]去掉最後空白
    #print(group[1].split(",")[:-1])
    gmember = group[1].split(",")[:-1]
    for j in range(len(gmember)):
        #print(gmember[j])
        print("&amp;lt;a href='../g"+str(gno)+"/"+str(gmember[j])+"'&amp;gt;"+ \
        str(gmember[j])+"&amp;lt;/a&amp;gt; ")
    print("&amp;lt;br /&amp;gt;")
    gno = gno + 1
&lt;/pre&gt;

&lt;p&gt;後記: 因為目前 (2016.12.29) 的 Brython 最新版 3.3.0 已經更改 Brython 安裝與連結方式, 因此本網頁中的程式改用 3.2.9 版&lt;/p&gt;</summary><category term="使用導引"></category><category term="創造力"></category><category term="表達能力"></category><category term="協同設計"></category></entry></feed>